    1: import { Injectable, Logger } from '@nestjs/common';
    2: import { InjectRepository } from '@nestjs/typeorm';
    3: import { Repository, In } from 'typeorm';
    4: import { ControleHorario } from '../entities/controle-horario.entity';
    5: import { FiltrosControleHorarioDto } from '../dto/filtros-controle-horario.dto';
    6: import { UpdateControleHorarioDto } from '../dto/update-controle-horario.dto';
    7: import { SingleControleHorarioUpdateDto } from '../dto/update-multiple-controle-horarios.dto';
    8: import { OracleService } from '../../database/oracle/services/oracle.service';
    9: import { createHash } from 'crypto';
   10: 
   11: @Injectable()
   12: export class ControleHorariosService {
   13:   private readonly logger = new Logger(ControleHorariosService.name);
   14: 
   15:   constructor(
   16:     @InjectRepository(ControleHorario)
   17:     private readonly controleHorarioRepository: Repository<ControleHorario>,
   18:     private readonly oracleService: OracleService,
   19:   ) {}
   20: 
   21:   async updateMultipleControleHorarios(
   22:     updates: SingleControleHorarioUpdateDto[],
   23:     editorNome: string,
   24:     editorEmail: string,
   25:   ): Promise<ControleHorario[]> {
   26:     this.logger.log(`?? Iniciando atualização de múltiplos controles de horário com ${updates.length} DTO(s).`);
   27:     const updatedRecords: ControleHorario[] = [];
   28:     const processedIds = new Set<string>();
   29: 
   30:     for (const updateDto of updates) {
   31:       const { id, ...fieldsToUpdate } = updateDto;
   32: 
   33:       // 1. Verificação de processamento duplicado
   34:       if (processedIds.has(id)) {
   35:         this.logger.log(`?? Pulando ID ${id} pois já foi processado neste lote.`);
   36:         continue;
   37:       }
   38: 
   39:       // 2. Verificação de campos para atualização
   40:       if (Object.keys(fieldsToUpdate).length === 0) {
   41:         this.logger.warn(`?? Nenhuma alteração solicitada para o ID ${id}. Pulando.`);
   42:         continue;
   43:       }
   44: 
   45:       const originalControleHorario = await this.controleHorarioRepository.findOne({ where: { id } });
   46: 
   47:       if (!originalControleHorario) {
   48:         this.logger.warn(`?? Controle de Horário com ID ${id} não encontrado.`);
   49:         continue;
   50:       }
   51: 
   52:       // 3. Guarda de segurança para propagação
   53:       const isPropagationSafe = originalControleHorario.cod_servico_numero && originalControleHorario.cracha_motorista;
   54:       if (!isPropagationSafe) {
   55:         this.logger.log(`?? Propagação não aplicável para o ID ${id}: serviço ou crachá do motorista ausente. Atualizando apenas este registro.`);
   56:         Object.assign(originalControleHorario, fieldsToUpdate, {
   57:           editado_por_nome: editorNome,
   58:           editado_por_email: editorEmail,
   59:           updated_at: new Date(),
   60:         });
   61:         updatedRecords.push(originalControleHorario);
   62:         processedIds.add(id);
   63:         continue;
   64:       }
   65: 
   66:       // --- Lógica de Propagação Controlada ---
   67:       this.logger.log(`[PROPAGAÇÃO INICIADA POR ID: ${id}]`);
   68:       this.logger.log(`Campos a serem propagados: ${Object.keys(fieldsToUpdate).join(', ')}`);
   69: 
   70:       const queryBuilder = this.controleHorarioRepository.createQueryBuilder('controle');
   71: 
   72:       // Critérios estritos de correspondência
   73:       queryBuilder.where('controle.data_referencia = :dataReferencia', { dataReferencia: originalControleHorario.data_referencia });
   74:       queryBuilder.andWhere('controle.cod_servico_numero = :codServicoNumero', { codServicoNumero: originalControleHorario.cod_servico_numero });
   75:       queryBuilder.andWhere('controle.cracha_motorista = :crachaMotorista', { crachaMotorista: originalControleHorario.cracha_motorista });
   76: 
   77:       // Propagação afeta apenas viagens futuras ou a atual
   78:       if (originalControleHorario.hor_saida) {
   79:         queryBuilder.andWhere('controle.hor_saida >= :anchorHora', { anchorHora: originalControleHorario.hor_saida });
   80:       }
   81: 
   82:       const relatedHorarios = await queryBuilder.getMany();
   83: 
   84:       this.logger.log(`[PROPAGAÇÃO ID: ${id}] Encontrados ${relatedHorarios.length} registros para aplicar alterações (Serviço: ${originalControleHorario.cod_servico_numero}, Motorista: ${originalControleHorario.cracha_motorista}).`);
   85: 
   86:       for (const relatedHorario of relatedHorarios) {
   87:         if (processedIds.has(relatedHorario.id)) continue;
   88: 
   89:         this.logger.log(`  -> Aplicando alterações no ID: ${relatedHorario.id}`);
   90:         Object.assign(relatedHorario, fieldsToUpdate, {
   91:           editado_por_nome: editorNome,
   92:           editado_por_email: editorEmail,
   93:           updated_at: new Date(),
   94:         });
   95:         
   96:         updatedRecords.push(relatedHorario);
   97:         processedIds.add(relatedHorario.id);
   98:       }
   99:       this.logger.log(`[PROPAGAÇÃO FINALIZADA PARA ID: ${id}]`);
  100:     }
  101: 
  102:     if (updatedRecords.length > 0) {
  103:       const uniqueRecords = Array.from(new Map(updatedRecords.map((r) => [r.id, r])).values());
  104:       
  105:       this.logger.log(`Salvando ${uniqueRecords.length} registros únicos no banco de dados.`);
  106:       await this.controleHorarioRepository.manager.transaction(async (transactionalEntityManager) => {
  107:         await transactionalEntityManager.save(ControleHorario, uniqueRecords);
  108:       });
  109: 
  110:       this.logger.log(`? ${uniqueRecords.length} registros atualizados com sucesso.`);
  111:     } else {
  112:       this.logger.log('?? Nenhuma alteração foi realizada no final do processo.');
  113:     }
  114: 
  115:     return Array.from(new Map(updatedRecords.map((r) => [r.id, r])).values());
  116:   }
  117: 
  118:   async buscarControleHorariosPorData(
  119:     dataReferencia: string,
  120:     filtros?: FiltrosControleHorarioDto,
  121:   ): Promise<ControleHorario[]> {
  122:     this.logger.log(`?? Buscando controle de horários para ${dataReferencia}`);
  123: 
  124:     const queryBuilder = this.controleHorarioRepository
  125:       .createQueryBuilder('controle')
  126:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  127:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true });
  128: 
  129:     // ? APLICAR FILTROS
  130:     if (filtros?.setores?.length > 0) {
  131:       queryBuilder.andWhere('controle.cod_local_terminal_sec IN (:...setores)', {
  132:         setores: filtros.setores,
  133:       });
  134:     }
  135: 
  136:     // Filtro de Linha (Múltipla Seleção)
  137:     if (filtros?.codigo_linha && filtros.codigo_linha.length > 0) {
  138:       queryBuilder.andWhere('controle.codigo_linha IN (:...codigo_linha)', {
  139:         codigo_linha: filtros.codigo_linha,
  140:       });
  141:     }
  142: 
  143:     if (filtros?.nome_linha) {
  144:       queryBuilder.andWhere('controle.nome_linha ILIKE :nome_linha', {
  145:         nome_linha: `%${filtros.nome_linha}%`,
  146:       });
  147:     }
  148: 
  149: 
  150: 
  151:     if (filtros?.setor_principal_linha) {
  152:       queryBuilder.andWhere('controle.setor_principal_linha = :setor_principal_linha', {
  153:         setor_principal_linha: filtros.setor_principal_linha,
  154:       });
  155:     }
  156: 
  157:     if (filtros?.local_origem_viagem) {
  158:       queryBuilder.andWhere('controle.local_origem_viagem ILIKE :local_origem_viagem', {
  159:         local_origem_viagem: `%${filtros.local_origem_viagem}%`,
  160:       });
  161:     }
  162: 
  163:     if (filtros?.cod_servico_numero) {
  164:       queryBuilder.andWhere('controle.cod_servico_numero ILIKE :cod_servico_numero', {
  165:         cod_servico_numero: `%${filtros.cod_servico_numero}%`,
  166:       });
  167:     }
  168: 
  169:     if (filtros?.nome_motorista) {
  170:       queryBuilder.andWhere('controle.nome_motorista ILIKE :nome_motorista', {
  171:         nome_motorista: `%${filtros.nome_motorista}%`,
  172:       });
  173:     }
  174: 
  175:     if (filtros?.nome_cobrador) {
  176:       queryBuilder.andWhere('controle.nome_cobrador ILIKE :nome_cobrador', {
  177:         nome_cobrador: `%${filtros.nome_cobrador}%`,
  178:       });
  179:     }
  180: 
  181:     if (filtros?.periodo_do_dia) {
  182:       queryBuilder.andWhere('controle.periodo_do_dia = :periodo_do_dia', {
  183:         periodo_do_dia: filtros.periodo_do_dia,
  184:       });
  185:     }
  186: 
  187:     if (filtros?.cod_atividade) {
  188:       queryBuilder.andWhere('controle.cod_atividade = :cod_atividade', {
  189:         cod_atividade: filtros.cod_atividade,
  190:       });
  191:     }
  192: 
  193:     if (filtros?.nome_atividade) {
  194:       queryBuilder.andWhere('controle.nome_atividade ILIKE :nome_atividade', {
  195:         nome_atividade: `%${filtros.nome_atividade}%`,
  196:       });
  197:     }
  198: 
  199:     if (filtros?.desc_tipodia) {
  200:       queryBuilder.andWhere('controle.desc_tipodia = :desc_tipodia', {
  201:         desc_tipodia: filtros.desc_tipodia,
  202:       });
  203:     }
  204: 
  205:     // Novos filtros
  206:     if (filtros?.prefixo_veiculo) {
  207:       queryBuilder.andWhere('controle.prefixo_veiculo ILIKE :prefixo_veiculo', {
  208:         prefixo_veiculo: `%${filtros.prefixo_veiculo}%`,
  209:       });
  210:     }
  211: 
  212:     if (filtros?.motorista_substituto_nome) {
  213:       queryBuilder.andWhere('controle.motorista_substituto_nome ILIKE :motorista_substituto_nome', {
  214:         motorista_substituto_nome: `%${filtros.motorista_substituto_nome}%`,
  215:       });
  216:     }
  217: 
  218:     if (filtros?.motorista_substituto_cracha) {
  219:       queryBuilder.andWhere('controle.motorista_substituto_cracha ILIKE :motorista_substituto_cracha', {
  220:         motorista_substituto_cracha: `%${filtros.motorista_substituto_cracha}%`,
  221:       });
  222:     }
  223: 
  224:     if (filtros?.cobrador_substituto_nome) {
  225:       queryBuilder.andWhere('controle.cobrador_substituto_nome ILIKE :cobrador_substituto_nome', {
  226:         cobrador_substituto_nome: `%${filtros.cobrador_substituto_nome}%`,
  227:       });
  228:     }
  229: 
  230:     if (filtros?.cobrador_substituto_cracha) {
  231:       queryBuilder.andWhere('controle.cobrador_substituto_cracha ILIKE :cobrador_substituto_cracha', {
  232:         cobrador_substituto_cracha: `%${filtros.cobrador_substituto_cracha}%`,
  233:       });
  234:     }
  235: 
  236:     // Filtro por Crachá (Motorista ou Cobrador)
  237:     if (filtros?.cracha_funcionario) {
  238:       queryBuilder.andWhere(
  239:         '(controle.cracha_motorista = :cracha_funcionario OR controle.cracha_cobrador = :cracha_funcionario)',
  240:         { cracha_funcionario: filtros.cracha_funcionario },
  241:       );
  242:     }
  243: 
  244:     // Filtro de Viagens Editadas
  245:     if (filtros?.apenas_editadas) {
  246:       queryBuilder.andWhere('controle.editado_por_nome IS NOT NULL');
  247:     }
  248: 
  249:     // Novos Filtros Implementados
  250:     // Mapear sentido_texto para flg_sentido
  251:     if (filtros?.sentido_texto) {
  252:       let flgSentido: string;
  253:       switch (filtros.sentido_texto.toUpperCase()) {
  254:         case 'IDA':
  255:           flgSentido = 'I';
  256:           break;
  257:         case 'VOLTA':
  258:           flgSentido = 'V';
  259:           break;
  260:         case 'CIRCULAR':
  261:           flgSentido = 'C';
  262:           break;
  263:         default:
  264:           flgSentido = '';
  265:       }
  266:       if (flgSentido) {
  267:         queryBuilder.andWhere('controle.flg_sentido = :flgSentido', { flgSentido });
  268:       }
  269:     }
  270: 
  271:     // Filtrar por horário de início
  272:     if (filtros?.horarioInicio) {
  273:       queryBuilder.andWhere('TO_CHAR(controle.hor_saida, \'HH24:MI\') >= :horarioInicio', { horarioInicio: filtros.horarioInicio });
  274:     }
  275: 
  276:     // Filtrar por horário de fim
  277:     if (filtros?.horarioFim) {
  278:       queryBuilder.andWhere('TO_CHAR(controle.hor_chegada, \'HH24:MI\') <= :horarioFim', { horarioFim: filtros.horarioFim });
  279:     }
  280: 
  281:     // Busca geral em múltiplos campos
  282:     if (filtros?.buscaTexto) {
  283:       queryBuilder.andWhere(
  284:         '(controle.nome_linha ILIKE :buscaTexto OR ' +
  285:         'controle.nome_motorista ILIKE :buscaTexto OR ' +
  286:         'controle.nome_cobrador ILIKE :buscaTexto OR ' +
  287:         'controle.prefixo_veiculo ILIKE :buscaTexto OR ' +
  288:         'controle.cod_servico_numero ILIKE :buscaTexto)',
  289:         { buscaTexto: `%${filtros.buscaTexto}%` },
  290:       );
  291:     }
  292: 
  293:     // Filtrar por email do editor
  294:     if (filtros?.editado_por_usuario_email) {
  295:       queryBuilder.andWhere('controle.editado_por_email = :editado_por_usuario_email', { editado_por_usuario_email: filtros.editado_por_usuario_email });
  296:     }
  297: 
  298:     // Filtrar por código do cobrador
  299:     if (filtros?.cod_cobrador) {
  300:       queryBuilder.andWhere('controle.cod_cobrador = :cod_cobrador', { cod_cobrador: filtros.cod_cobrador });
  301:     }
  302: 
  303:     // ? PAGINAÇÃO
  304:     if (filtros?.limite) {
  305:       queryBuilder.limit(filtros.limite);
  306:     }
  307: 
  308:     if (filtros?.pagina && filtros?.limite) {
  309:       queryBuilder.offset((filtros.pagina - 1) * filtros.limite);
  310:     }
  311: 
  312:     // ? ORDENAÇÃO
  313:     if (filtros?.ordenar_por && filtros?.ordem) {
  314:       let orderByColumn = filtros.ordenar_por;
  315:       // Mapear propriedades da entidade para nomes de coluna do banco de dados, se necessário
  316:       if (orderByColumn.toLowerCase() === 'desc_tipodia') {
  317:         orderByColumn = 'desc_tipodia';
  318:       } else if (orderByColumn === 'codigo_linha') {
  319:         orderByColumn = 'codigo_linha';
  320:       } else if (orderByColumn === 'nome_motorista') {
  321:         orderByColumn = 'nome_motorista';
  322:       }
  323:       queryBuilder.orderBy(`controle.${orderByColumn}`, filtros.ordem);
  324:     } else {
  325:       queryBuilder
  326:         .orderBy('controle.setor_principal_linha', 'ASC')
  327:         .addOrderBy('controle.codigo_linha', 'ASC')
  328:         .addOrderBy('controle.hor_saida', 'ASC');
  329:     }
  330: 
  331:     const horarios = await queryBuilder.getMany();
  332: 
  333:     this.logger.log(`? Encontrados ${horarios.length} registros no PostgreSQL`);
  334:     return horarios;
  335:   }
  336: 
  337:   async sincronizarControleHorariosPorData(dataReferencia: string): Promise<{
  338:     sincronizadas: number;
  339:     novas: number;
  340:     atualizadas: number;
  341:     erros: number;
  342:     desativadas: number;
  343:   }> {
  344:     this.logger.log(`?? Sincronizando controle de horários para ${dataReferencia}`);
  345: 
  346:     try {
  347:       if (!this.oracleService.isEnabled()) {
  348:         this.logger.warn('?? Oracle está desabilitado');
  349:         return { sincronizadas: 0, novas: 0, atualizadas: 0, erros: 1, desativadas: 0 };
  350:       }
  351: 
  352:       // Deleta os registros existentes para a data de referência
  353:       this.logger.log(`??? Deletando registros existentes para a data ${dataReferencia}`);
  354:       await this.controleHorarioRepository.delete({ data_referencia: dataReferencia });
  355: 
  356:       const sqlQuery = `
  357:         SELECT
  358:             CASE
  359:                 WHEN L.COD_LOCAL_TERMINAL_SEC = 7000 THEN 'GAMA'
  360:                 WHEN L.COD_LOCAL_TERMINAL_SEC = 6000 THEN 'SANTA MARIA'
  361:                 WHEN L.COD_LOCAL_TERMINAL_SEC = 8000 THEN 'PARANOÁ'
  362:                 WHEN L.COD_LOCAL_TERMINAL_SEC = 9000 THEN 'SÃO SEBASTIÃO'
  363:             END AS SETOR_PRINCIPAL_LINHA,
  364:             L.COD_LOCAL_TERMINAL_SEC,
  365:             L.CODIGOLINHA,
  366:             L.NOMELINHA,
  367:             L.DESTINOLINHA AS COD_DESTINO_LINHA,
  368:             NLD.DESC_LOCALIDADE AS LOCAL_DESTINO_LINHA,
  369:             H.FLG_SENTIDO,
  370:             TO_CHAR(D.DAT_ESCALA, 'YYYY-MM-DD') AS DATA_VIAGEM,
  371:             CASE TO_CHAR(D.DAT_ESCALA, 'DY', 'NLS_DATE_LANGUAGE=PORTUGUESE')
  372:                 WHEN 'DOM' THEN 'DOMINGO'
  373:                 WHEN 'SÁB' THEN 'SABADO'
  374:                 ELSE 'DIAS UTEIS'
  375:             END AS DESC_TIPODIA,
  376:             TO_CHAR(H.HOR_SAIDA, 'HH24:MI:SS') AS HOR_SAIDA,
  377:             TO_CHAR(H.HOR_CHEGADA, 'HH24:MI:SS') AS HOR_CHEGADA,
  378:             H.COD_LOCALIDADE AS COD_ORIGEM_VIAGEM,
  379:             LCO.DESC_LOCALIDADE AS LOCAL_ORIGEM_VIAGEM,
  380:             S.COD_SERVDIARIA AS COD_SERVICO_COMPLETO,
  381:             REGEXP_SUBSTR(S.COD_SERVDIARIA, '[[:digit:]]+') AS COD_SERVICO_NUMERO,
  382:             H.COD_ATIVIDADE,
  383:             CASE H.COD_ATIVIDADE
  384:                 WHEN 2 THEN 'REGULAR'
  385:                 WHEN 3 THEN 'ESPECIAL'
  386:                 WHEN 4 THEN 'RENDIÇÃO'
  387:                 WHEN 5 THEN 'RECOLHIMENTO'
  388:                 WHEN 10 THEN 'RESERVA'
  389:                 ELSE 'OUTROS'
  390:             END AS NOME_ATIVIDADE,
  391:             CASE H.COD_ATIVIDADE
  392:                 WHEN 2 THEN 'R'
  393:                 ELSE 'S'
  394:             END AS FLG_TIPO,
  395:             S.COD_MOTORISTA,
  396:             FM.NOMECOMPLETOFUNC AS NOME_MOTORISTA,
  397:             FM.CODFUNC AS CRACHA_MOTORISTA,
  398:             FM.CHAPAFUNC AS CHAPAFUNC_MOTORISTA,
  399:             S.COD_COBRADOR,
  400:             FC.NOMECOMPLETOFUNC AS NOME_COBRADOR,
  401:             FC.CODFUNC AS CRACHA_COBRADOR,
  402:             FC.CHAPAFUNC AS CHAPAFUNC_COBRADOR,
  403:             COUNT(H.HOR_SAIDA) OVER (
  404:                 PARTITION BY L.COD_LOCAL_TERMINAL_SEC, L.CODIGOLINHA
  405:             ) AS TOTAL_HORARIOS
  406:         FROM
  407:             T_ESC_ESCALADIARIA D
  408:             JOIN T_ESC_SERVICODIARIA S ON D.DAT_ESCALA = S.DAT_ESCALA AND D.COD_INTESCALA = S.COD_INTEScala
  409:             JOIN T_ESC_HORARIODIARIA H ON D.DAT_ESCALA = H.DAT_ESCALA AND D.COD_INTESCALA = H.COD_INTESCALA
  410:                 AND S.COD_SERVDIARIA = H.COD_INTSERVDIARIA
  411:                 AND H.COD_INTTURNO = S.COD_INTTURNO
  412:             JOIN BGM_CADLINHAS L ON DECODE(H.CODINTLINHA, NULL, D.COD_INTLINHA, H.CODINTLINHA) = L.CODINTLINHA
  413:             LEFT JOIN T_ESC_LOCALIDADE LCO ON H.COD_LOCALIDADE = LCO.COD_LOCALIDADE
  414:             LEFT JOIN T_ESC_LOCALIDADE NLD ON L.DESTINOLINHA = NLD.COD_LOCALIDADE
  415:             LEFT JOIN FLP_FUNCIONARIOS FM ON S.COD_MOTORISTA = FM.CODINTFUNC
  416:             LEFT JOIN FLP_FUNCIONARIOS FC ON S.COD_COBRADOR = FC.CODINTFUNC
  417:         WHERE
  418:             H.COD_ATIVIDADE IN (2, 3, 4, 5, 10)
  419:             AND L.CODIGOEMPRESA = 4
  420:             AND UPPER(L.NOMELINHA) NOT LIKE '%DESPACHANTES%'
  421:             AND UPPER(L.NOMELINHA) NOT LIKE '%LINHA ESPECIAL%'
  422:             AND UPPER(L.NOMELINHA) NOT LIKE '%DUPLAS RESERVAS%'
  423:             AND L.COD_LOCAL_TERMINAL_SEC IN (6000, 7000, 8000, 9000)
  424:             AND TRUNC(D.DAT_ESCALA) = TO_DATE('${dataReferencia}', 'YYYY-MM-DD')
  425:         ORDER BY
  426:             SETOR_PRINCIPAL_LINHA,
  427:             L.CODIGOLINHA,
  428:             H.FLG_SENTIDO,
  429:             H.HOR_SAIDA
  430:       `;
  431: 
  432:       const dadosOracle = await this.oracleService.executeHeavyQuery(sqlQuery);
  433: 
  434:       this.logger.log(`?? Oracle Globus retornou ${dadosOracle.length} registros para controle de horários`);
  435: 
  436:       if (dadosOracle.length === 0) {
  437:         this.logger.warn(`?? Nenhum dado encontrado no Oracle para ${dataReferencia}`);
  438:         return { sincronizadas: 0, novas: 0, atualizadas: 0, erros: 0, desativadas: 0 };
  439:       }
  440: 
  441:       let novas = 0;
  442:       let erros = 0;
  443: 
  444:       const BATCH_SIZE = 100;
  445:       for (let i = 0; i < dadosOracle.length; i += BATCH_SIZE) {
  446:         const lote = dadosOracle.slice(i, i + BATCH_SIZE);
  447:         const loteProcessado = lote.map(item => this.processarDadosOracle(item, dataReferencia));
  448:         
  449:         // Filter out duplicates based on hash_dados within the current batch
  450:         const uniqueLoteProcessado = Array.from(new Map(loteProcessado.map(item => [item.hash_dados, item])).values());
  451: 
  452:         try {
  453:           await this.controleHorarioRepository.upsert(
  454:             uniqueLoteProcessado, // Use the unique list here
  455:             {
  456:               conflictPaths: ['hash_dados'],
  457:               skipUpdateIfNoValuesChanged: true,
  458:             },
  459:           );
  460:           novas += uniqueLoteProcessado.length; // Count unique items
  461:         } catch (error: any) {
  462:           this.logger.error(`? Erro ao salvar/atualizar lote (upsert): ${error.message}`);
  463:           erros += uniqueLoteProcessado.length; // Count unique items that caused error
  464:         }
  465: 
  466:         if (i % (BATCH_SIZE * 10) === 0) {
  467:           this.logger.log(`?? Processados ${i + BATCH_SIZE}/${dadosOracle.length} registros...`);
  468:         }
  469:       }
  470: 
  471:       const sincronizadas = novas;
  472: 
  473:       this.logger.log(`? Sincronização de controle de horários concluída: ${sincronizadas} total (${novas} novas, 0 atualizadas, 0 desativadas, ${erros} erros)`);
  474: 
  475:       return { sincronizadas, novas, atualizadas: 0, erros, desativadas: 0 };
  476: 
  477:     } catch (error: any) {
  478:       this.logger.error(`? Erro na sincronização de controle de horários: ${error.message}`);
  479:       throw error;
  480:     }
  481:   }
  482: 
  483:   private processarDadosOracle(item: any, dataReferencia: string): Partial<ControleHorario> {
  484:     const horSaida = this.processarHorarioOracle(item.HOR_SAIDA, dataReferencia);
  485:     const horChegada = this.processarHorarioOracle(item.HOR_CHEGADA, dataReferencia);
  486: 
  487:     const sentidoTexto = this.determinarSentidoTexto(item.FLG_SENTIDO);
  488:     const periodoDoDia = this.determinarPeriodoDoDia(horSaida);
  489: 
  490:     const controle = new ControleHorario();
  491: 
  492:     controle.setor_principal_linha = item.SETOR_PRINCIPAL_LINHA || '';
  493:     controle.cod_local_terminal_sec = item.COD_LOCAL_TERMINAL_SEC || 0;
  494:     controle.codigo_linha = item.CODIGOLINHA || '';
  495:     if (!item.CODIGOLINHA) {
  496:       this.logger.warn(`CODIGOLINHA is missing for item: ${JSON.stringify(item)}`);
  497:     }
  498:     controle.nome_linha = item.NOMELINHA || '';
  499:     if (!item.NOMELINHA) {
  500:       this.logger.warn(`NOMELINHA is missing for item: ${JSON.stringify(item)}`);
  501:     }
  502:     controle.cod_destino_linha = item.COD_DESTINO_LINHA || null;
  503:     controle.local_destino_linha = item.LOCAL_DESTINO_LINHA || null;
  504:     controle.flg_sentido = item.FLG_SENTIDO || null;
  505:     controle.data_viagem = item.DATA_VIAGEM ? new Date(item.DATA_VIAGEM) : null;
  506:     controle.desc_tipodia = item.DESC_TIPODIA || null;
  507:     controle.hor_saida = horSaida;
  508:     if (!horSaida) {
  509:       this.logger.warn(`HOR_SAIDA is missing or invalid for item: ${JSON.stringify(item)}`);
  510:     }
  511:     controle.hor_chegada = horChegada;
  512:     if (!horChegada) {
  513:       this.logger.warn(`HOR_CHEGADA is missing or invalid for item: ${JSON.stringify(item)}`);
  514:     }
  515:     controle.cod_motorista = item.COD_MOTORISTA || null;
  516:     controle.nome_motorista = item.NOME_MOTORISTA || null;
  517:     controle.cracha_motorista = item.CRACHA_MOTORISTA || null;
  518:     controle.chapa_func_motorista = item.CHAPAFUNC_MOTORISTA || null;
  519:     controle.cod_cobrador = item.COD_COBRADOR || null;
  520:     controle.nome_cobrador = item.NOME_COBRADOR || null;
  521:     controle.cracha_cobrador = item.CRACHA_COBRADOR || null;
  522:     controle.chapa_func_cobrador = item.CHAPAFUNC_COBRADOR || null;
  523:     controle.total_horarios = item.TOTAL_HORARIOS || null;
  524: 
  525:     // Novos campos - inicialmente nulos ou vazios, pois vêm da edição do frontend
  526:     controle.placaVeiculo = null;
  527:     controle.prefixo_veiculo = null;
  528:     controle.garagemVeiculo = null;
  529:     controle.motorista_substituto_nome = null;
  530:     controle.motorista_substituto_cracha = null;
  531:     controle.cobrador_substituto_nome = null;
  532:     controle.cobrador_substituto_cracha = null;
  533:     controle.observacoes_edicao = null;
  534:     controle.editado_por_nome = null;
  535:     controle.editado_por_email = null;
  536: 
  537:     controle.data_referencia = dataReferencia;
  538:     controle.sentido_texto = sentidoTexto;
  539:     controle.periodo_do_dia = periodoDoDia;
  540:     controle.tem_cobrador = !!(item.COD_COBRADOR && item.NOME_COBRADOR);
  541:     controle.origem_dados = 'ORACLE_GLOBUS';
  542:     controle.is_ativo = true;
  543: 
  544:     controle.hash_dados = controle.gerarHashDados();
  545: 
  546:     return controle;
  547:   }
  548: 
  549:   private processarHorarioOracle(horarioOracle: any, dataReferencia: string): Date | null {
  550:     if (!horarioOracle) return null;
  551: 
  552:     // Parse dataReferencia to get year, month, day
  553:     const dateParts = dataReferencia.split('-').map(Number);
  554:     const year = dateParts[0];
  555:     // Month is 0-indexed in JavaScript Date
  556:     const month = dateParts[1] - 1;
  557:     const day = dateParts[2];
  558: 
  559:     // Lida com o formato de string 'HH:MI:SS' vindo do TO_CHAR
  560:     if (typeof horarioOracle === 'string' && /^\d{2}:\d{2}:\d{2}$/.test(horarioOracle)) {
  561:       try {
  562:         const [hours, minutes, seconds] = horarioOracle.split(':').map(Number);
  563:         // Construct a Date object in UTC to avoid local timezone shifts during creation
  564:         // This will ensure the internal representation is exactly what we want
  565:         return new Date(year, month, day, hours, minutes, seconds);
  566:       } catch (error) {
  567:         this.logger.error(`Erro ao processar string de horário: ${horarioOracle}`, error);
  568:         return null;
  569:       }
  570:     }
  571: 
  572:     // Lógica original para lidar com objetos Date do Oracle (less likely given TO_CHAR in query)
  573:     try {
  574:       const data = new Date(horarioOracle);
  575:       if (isNaN(data.getTime())) {
  576:         this.logger.warn(`Data inválida recebida do Oracle: ${horarioOracle}`);
  577:         return null;
  578:       }
  579:       // If it's already a Date object, we still want to ensure it's treated as a local time
  580:       // and combined with the dataReferencia.
  581:       // This part might need more context if Oracle is returning actual Date objects with timezone info.
  582:       // For now, assuming it's a time component that needs to be combined with dataReferencia.
  583:       return new Date(Date.UTC(year, month, day, data.getHours(), data.getMinutes(), data.getSeconds()));
  584:     } catch (error) {
  585:       this.logger.error(`Erro ao processar data do Oracle: ${horarioOracle}`, error);
  586:       return null;
  587:     }
  588:   }
  589: 
  590:   private determinarSentidoTexto(flgSentido: string): string {
  591:     switch (flgSentido?.toUpperCase()) {
  592:       case 'I':
  593:         return 'IDA';
  594:       case 'V':
  595:         return 'VOLTA';
  596:       case 'C':
  597:         return 'CIRCULAR';
  598:       default:
  599:         return 'NÃO INFORMADO';
  600:     }
  601:   }
  602: 
  603:   private determinarPeriodoDoDia(horario: Date | null): string {
  604:     if (!horario) return 'NÃO INFORMADO';
  605: 
  606:     const hora = horario.getHours();
  607: 
  608:     if (hora >= 5 && hora < 12) return 'MANHÃ';
  609:     if (hora >= 12 && hora < 18) return 'TARDE';
  610:     if (hora >= 18 && hora < 24) return 'NOITE';
  611:     return 'MADRUGADA';
  612:   }
  613: 
  614:   async obterStatusDados(dataReferencia: string): Promise<{
  615:     existeNoBanco: boolean;
  616:     totalRegistros: number;
  617:     ultimaAtualizacao: Date | null;
  618:     setoresDisponiveis: string[];
  619:     linhasDisponiveis: number;
  620:     atividadesDisponiveis: string[];
  621:     tiposDiaDisponiveis: string[];
  622:   }> {
  623:     const totalRegistros = await this.controleHorarioRepository.count({
  624:       where: { data_referencia: dataReferencia, is_ativo: true },
  625:     });
  626: 
  627:     const ultimaAtualizacao = totalRegistros > 0
  628:       ? (await this.controleHorarioRepository.findOne({
  629:           where: { data_referencia: dataReferencia, is_ativo: true },
  630:           order: { updated_at: 'DESC' },
  631:           select: ['updated_at'],
  632:         }))?.updated_at || null
  633:       : null;
  634: 
  635:     const setoresDisponiveis = await this.controleHorarioRepository
  636:       .createQueryBuilder('controle')
  637:       .select('DISTINCT controle.setor_principal_linha', 'setor')
  638:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  639:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  640:       .andWhere('controle.setor_principal_linha IS NOT NULL')
  641:       .getRawMany()
  642:       .then((result) => result.map((r) => r.setor));
  643: 
  644:     const linhasDisponiveis = await this.controleHorarioRepository
  645:       .createQueryBuilder('controle')
  646:       .select('COUNT(DISTINCT controle.codigo_linha)', 'count')
  647:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  648:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  649:       .getRawOne()
  650:       .then((result) => parseInt(result?.count || '0'));
  651: 
  652:     const atividadesDisponiveis = await this.controleHorarioRepository
  653:       .createQueryBuilder('controle')
  654:       .select('DISTINCT controle.nome_atividade', 'atividade')
  655:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  656:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  657:       .andWhere('controle.nome_atividade IS NOT NULL')
  658:       .getRawMany()
  659:       .then((result) => result.map((r) => r.atividade));
  660: 
  661:     const tiposDiaDisponiveis = await this.controleHorarioRepository
  662:       .createQueryBuilder('controle')
  663:       .select('DISTINCT controle.desc_tipodia', 'descTipodia')
  664:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  665:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  666:       .andWhere('controle.desc_tipodia IS NOT NULL')
  667:       .getRawMany()
  668:       .then((result) => result.map((r) => r.descTipodia));
  669: 
  670:     return {
  671:       existeNoBanco: totalRegistros > 0,
  672:       totalRegistros,
  673:       ultimaAtualizacao,
  674:       setoresDisponiveis,
  675:       linhasDisponiveis,
  676:       atividadesDisponiveis,
  677:       tiposDiaDisponiveis,
  678:     };
  679:   }
  680: 
  681:   async obterCodigosLinha(dataReferencia: string): Promise<string[]> {
  682:     const result = await this.controleHorarioRepository
  683:       .createQueryBuilder('controle')
  684:       .select('DISTINCT controle.codigo_linha', 'codigoLinha')
  685:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  686:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  687:       .andWhere('controle.codigo_linha IS NOT NULL')
  688:       .orderBy('controle.codigo_linha', 'ASC')
  689:       .getRawMany();
  690: 
  691:     return result.map((r) => r.codigoLinha);
  692:   }
  693: 
  694:   async obterServicosUnicos(dataReferencia: string): Promise<string[]> {
  695:     const result = await this.controleHorarioRepository
  696:       .createQueryBuilder('controle')
  697:       .select('DISTINCT controle.cod_servico_numero', 'servico')
  698:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  699:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  700:       .andWhere('controle.cod_servico_numero IS NOT NULL')
  701:       .orderBy('servico', 'ASC')
  702:       .getRawMany();
  703: 
  704:     return result.map((r) => r.servico);
  705:   }
  706: 
  707:   async obterSetoresUnicos(dataReferencia: string): Promise<string[]> {
  708:     const result = await this.controleHorarioRepository
  709:       .createQueryBuilder('controle')
  710:       .select('DISTINCT controle.setor_principal_linha', 'setor')
  711:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  712:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  713:       .andWhere('controle.setor_principal_linha IS NOT NULL')
  714:       .orderBy('setor', 'ASC')
  715:       .getRawMany();
  716: 
  717:     return result.map((r) => r.setor);
  718:   }
  719: 
  720:   async obterAtividadesUnicas(dataReferencia: string): Promise<string[]> {
  721:     const result = await this.controleHorarioRepository
  722:       .createQueryBuilder('controle')
  723:       .select('DISTINCT controle.nome_atividade', 'atividade')
  724:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  725:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  726:       .andWhere('controle.nome_atividade IS NOT NULL')
  727:       .orderBy('atividade', 'ASC')
  728:       .getRawMany();
  729: 
  730:     return result.map((r) => r.atividade);
  731:   }
  732: 
  733:   async obterTiposDiaUnicos(dataReferencia: string): Promise<string[]> {
  734:     const result = await this.controleHorarioRepository
  735:       .createQueryBuilder('controle')
  736:       .select('controle.desc_tipodia')
  737:       .where('controle.data_referencia = :dataReferencia', { dataReferencia })
  738:       .andWhere('controle.is_ativo = :isAtivo', { isAtivo: true })
  739:       .andWhere('controle.desc_tipodia IS NOT NULL')
  740:       .orderBy('controle.desc_tipodia', 'ASC')
  741:       .getRawMany();
  742: 
  743:     return [...new Set(result.map((r) => r.controle_desc_tipodia))];
  744:   }
  745: 
  746:   async testarConexaoOracle(): Promise<{
  747:     success: boolean;
  748:     message: string;
  749:     connectionInfo?: any;
  750:   }> {
  751:     try {
  752:       const isConnected = await this.oracleService.testConnection();
  753: 
  754:       if (isConnected) {
  755:         const connectionInfo = await this.oracleService.getConnectionInfo();
  756: 
  757:         return {
  758:           success: true,
  759:           message: 'Conexão Oracle Globus funcionando',
  760:           connectionInfo,
  761:         };
  762:       } else {
  763:         return {
  764:           success: false,
  765:           message: 'Falha na conexão Oracle Globus',
  766:         };
  767:       }
  768:     } catch (error: any) {
  769:       return {
  770:         success: false,
  771:         message: `Erro ao testar conexão Oracle Globus: ${error.message}`,
  772:       };
  773:     }
  774:   }
  775: 
  776:   async obterEstatisticasOracle(dataReferencia: string): Promise<any> {
  777:     try {
  778:       const statsQuery = `
  779:         SELECT
  780:           COUNT(*) as TOTAL_REGISTROS_HOJE,
  781:           COUNT(DISTINCT L.CODIGOLINHA) as TOTAL_LINHAS,
  782:           COUNT(DISTINCT L.COD_LOCAL_TERMINAL_SEC) as TOTAL_SETORES,
  783:           COUNT(DISTINCT S.COD_MOTORISTA) as TOTAL_MOTORISTAS,
  784:           MIN(H.HOR_SAIDA) as PRIMEIRO_HORARIO,
  785:           MAX(H.HOR_CHEGADA) as ULTIMO_HORARIO
  786:         FROM T_ESC_ESCALADIARIA D
  787:         JOIN T_ESC_SERVICODIARIA S ON D.DAT_ESCALA = S.DAT_ESCALA AND D.COD_INTESCALA = S.COD_INTESCALA
  788:         JOIN T_ESC_HORARIODIARIA H ON D.DAT_ESCALA = H.DAT_ESCALA AND D.COD_INTESCALA = H.COD_INTESCALA
  789:         JOIN BGM_CADLINHAS L ON DECODE(H.CODINTLINHA, NULL, D.COD_INTLINHA, H.CODINTLINHA) = L.CODINTLINHA
  790:         WHERE H.COD_ATIVIDADE IN (2, 3, 4, 5, 10)
  791:           AND L.CODIGOEMPRESA = 4
  792:           AND UPPER(L.NOMELINHA) NOT LIKE '%DESPACHANTES%'
  793:           AND UPPER(L.NOMELINHA) NOT LIKE '%LINHA ESPECIAL%'
  794:           AND UPPER(L.NOMELINHA) NOT LIKE '%DUPLAS RESERVAS%'
  795:           AND L.COD_LOCAL_TERMINAL_SEC IN (6000, 7000, 8000, 9000)
  796:           AND TRUNC(D.DAT_ESCALA) = TO_DATE('${dataReferencia}', 'YYYY-MM-DD')
  797:         ORDER BY
  798:             SETOR_PRINCIPAL_LINHA,
  799:             L.CODIGOLINHA,
  800:             H.FLG_SENTIDO,
  801:             H.HOR_SAIDA
  802:       `;
  803: 
  804:       const stats = await this.oracleService.executeQuery(statsQuery);
  805:       return {
  806:         success: true,
  807:         data: stats[0] || {},
  808:         source: 'ORACLE_GLOBUS',
  809:       };
  810:     } catch (error: any) {
  811:       return {
  812:         success: false,
  813:         message: `Erro ao obter estatísticas Oracle: ${error.message}`,
  814:       };
  815:     }
  816:   }
  817: 
  818:   async updateControleHorario(
  819:     id: string,
  820:     updateDto: UpdateControleHorarioDto,
  821:     editorNome: string,
  822:     editorEmail: string,
  823:   ): Promise<ControleHorario> {
  824:     this.logger.log(`?? Atualizando controle de horário com ID: ${id}`);
  825: 
  826:     const controleHorario = await this.controleHorarioRepository.findOne({ where: { id } });
  827: 
  828:     if (!controleHorario) {
  829:       throw new Error(`Controle de Horário com ID ${id} não encontrado.`);
  830:     }
  831: 
  832:     const camposPropagaveis = [
  833:       'prefixo_veiculo',
  834:       'motorista_substituto_nome',
  835:       'motorista_substituto_cracha',
  836:       'cobrador_substituto_nome',
  837:       'cobrador_substituto_cracha',
  838:     ];
  839: 
  840:     const devePropagar = camposPropagaveis.some(key => key in updateDto);
  841: 
  842:     if (devePropagar) {
  843:       this.logger.log(`?? Detecção de campos propagáveis. Acionando a lógica de atualização múltipla para o ID: ${id}`);
  844:       
  845:       const updateForward: SingleControleHorarioUpdateDto = { id, ...updateDto };
  846:       
  847:       const atualizados = await this.updateMultipleControleHorarios([updateForward], editorNome, editorEmail);
  848:       
  849:       const registroAtualizado = atualizados.find((r) => r.id === id);
  850:       
  851:       if (registroAtualizado) {
  852:         return registroAtualizado;
  853:       }
  854:       
  855:       this.logger.warn(`?? O registro com ID ${id} não foi encontrado no resultado da propagação. Retornando o estado original.`);
  856:       return controleHorario; // Retorna o original se algo der errado na propagação
  857:     } else {
  858:       this.logger.log(`??? Nenhuma alteração propagável detectada. Atualizando apenas o registro com ID: ${id}`);
  859:       
  860:       Object.assign(controleHorario, updateDto, {
  861:         editado_por_nome: editorNome,
  862:         editado_por_email: editorEmail,
  863:         updated_at: new Date(),
  864:       });
  865: 
  866:       return this.controleHorarioRepository.save(controleHorario);
  867:     }
  868:   }
  869: }
